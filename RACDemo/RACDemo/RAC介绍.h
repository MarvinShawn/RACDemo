

/*
 函数式编程（Functional Programming）：使用高阶函数，例如函数用其他函数作为参数。
 
 响应式编程（Reactive Programming）：关注于数据流和变化传播。响应式编程可以避免使用追踪瞬时状态的的实例变量。    不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。
 
 f1(x) = x + 1   ==>给URL,返回数据
 
 f2(f1(x)) = 2x+ 1  ==>把数据转化为模型
 
 f3(f2(f1(x)) ) = 3x + 1  ==> 更新UI
 
 
 RAC(ReactiveCocoa)  核心:响应数据的变化    (通过信号来记录值的变化)
 

使用RAC的好处:
 
" 如果全工程都使用RAC来实现，对于同一个业务逻辑可以在同一块代码里完成了，将UI事件，逻辑处理，文件或数据库操作，异步网络请求，UI结果显示，这一大套统统用函数式编程的思路嵌套起来，进入页面时搭建好这所有的关系，用户点击后妥妥的等着这一套联系一个个的按期望的逻辑和次序触发，最后显示给用户。"
 
 在iOS开发过程中，经常会响应某些事件来处理某些业务逻辑，例如按钮的点击，上下拉刷新，网络请求，属性的变化（通过KVO）或者用户位置的变化（通过CoreLocation）。但是这些事件都用不同的方式来处理，比如action、delegate、KVO、callback等。ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中高聚合，低耦合的思想。
 
缺点:  代码有些晦涩难懂,假如一个开发小组里面只有部分人会用RAC,别的人并不会用,就会影响开发进度,而且,后期的话如果对RAC驾驭不够成熟,比较难维护.            调试起来比较困难
 
 //孙源
 //http://blog.sunnyxx.com/2014/03/06/rac_0_overview/
 
 //http://blog.sunnyxx.com/2014/03/06/rac_1_macros/
 
 //http://blog.sunnyxx.com/2014/03/06/rac_2_racstream/
 
 //http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/
 
 //http://blog.sunnyxx.com/2014/04/19/rac_4_filters/
 
 
 //李忠
 //http://limboy.me/tech/2013/06/19/frp-reactivecocoa.html
 
 //http://limboy.me/tech/2013/12/27/reactivecocoa-2.html 
 
 //http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html
 
 "可以把信号想象成水龙头，只不过里面不是水，而是玻璃球(value)，直径跟水管的内径一样，这样就能保证玻璃球是依次排列，不会出现并排的情况(数据都是线性处理的，不会出现并发情况)。水龙头的开关默认是关的，除非有了接收方(subscriber)，才会打开。这样只要有新的玻璃球进来，就会自动传送给接收方。可以在水龙头上加一个过滤嘴(filter)，不符合的不让通过，也可以加一个改动装置，把球改变成符合自己的需求(map)。也可以把多个水龙头合并成一个新的水龙头(combineLatest:reduce:)，这样只要其中的一个水龙头有玻璃球出来，这个新合并的水龙头就会得到这个球。"
 
 
 //简书
 //http://www.jianshu.com/p/87ef6720a096   基础
 
 //http://www.jianshu.com/p/e10e5ca413b7  进阶
 */

/********************************Operations************************************
 
 ------------------------------映射-------------------------------
 flattenMap，Map用于把源信号内容映射成新的内容。
 1.FlatternMap中的Block返回信号。
 2.Map中的Block返回对象。
 3.开发中，如果信号发出的值不是信号，映射一般使用Map
 4.开发中，如果信号发出的值是信号，映射一般使用FlatternMap。
 
 ----------------------------组合 ----------------------------------
 concat:按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号。
 
 then:用于连接两个信号，当第一个信号完成，才会连接then返回的信号。
 
 merge:把多个信号合并为一个信号，任何一个信号有新值的时候就会调用
 
 zipWith:把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。
 
 combineLatest:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。
 
 reduce聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值
 
  ----------------------------过滤 ----------------------------------
 filter:过滤信号，使用它可以获取满足条件的信号.
 
 ignore:忽略完某些值的信号.
 
 distinctUntilChanged:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。 // 在开发中，刷新UI经常使用，只有两次数据不一样才需要刷新
 
 take:从开始一共取N次的信号
 
 takeLast:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号.
 
 takeUntil:(RACSignal *):获取信号直到某个信号执行完成
 
 skip:(NSUInteger):跳过几个信号,不接受。
 
 switchToLatest:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。
 
 
   -------------------------------秩序------------------------------
 doNext: 执行Next之前，会先执行这个Block
 doCompleted: 执行sendCompleted之前，会先执行这个Block
 
 

  -------------------------------线程------------------------------
 deliverOn: 内容传递切换到制定线程中，副作用在原来线程中,把在创建信号时block中的代码称之为副作用。
 
 subscribeOn: 内容传递和副作用都会切换到制定线程中。
 

   -------------------------------时间------------------------------
 timeout：超时，可以让一个信号在一定的时间后，自动报错。
 interval 定时：每隔一段时间发出信号
 delay 延迟发送next。
 
 
    -------------------------------重复------------------------------
 retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功.
 replay重放：当一个信号被多次订阅,反复播放内容
 throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。
 
 
 
 //RACChannelTo(self, blockShowText) = RACChannelTo(self.viewModel, blockShowText);
 //双向绑定(任何一端有变化,另外一方都会有变化)

 
 
 #import "EXTScope.h"
 
 */

